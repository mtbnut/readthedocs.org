{
  "path": "",
  "title": "",
  "sections": [
    {
      "id": "module-sphinx.ext.autodoc",
      "title": "sphinx.ext.autodoc \u2013 Include documentation from docstrings",
      "content": "This extension can import the modules you are documenting, and pull in documentation from docstrings in a semi-automatic way. Note For Sphinx (actually, the Python interpreter that executes Sphinx) to find your module, it must be importable. That means that the module or the package must be in one of the directories on sys.path \u2013 adapt your sys.path in the configuration file accordingly. Warning autodoc imports the modules to be documented. If any modules have side effects on import, these will be executed by autodoc when sphinx-build is run. If you document scripts (as opposed to library modules), make sure their main routine is protected by a if __name__ == '__main__' condition. For this to work, the docstrings must of course be written in correct reStructuredText. You can then use all of the usual Sphinx markup in the docstrings, and it will end up correctly in the documentation. Together with hand-written documentation, this technique eases the pain of having to maintain two locations for documentation, while at the same time avoiding auto-generated-looking pure API documentation. If you prefer NumPy or Google style docstrings over reStructuredText, you can also enable the napoleon extension. napoleon is a preprocessor that converts your docstrings to correct reStructuredText before autodoc processes them."
    },
    {
      "id": "directives",
      "title": "Directives",
      "content": "autodoc provides several directives that are versions of the usual py:module, py:class and so forth. On parsing time, they import the corresponding module and extract the docstring of the given objects, inserting them into the page source under a suitable py:module, py:class etc. directive. Note Just as py:class respects the current py:module, autoclass will also do so. Likewise, automethod will respect the current py:class. .. automodule:: .. autoclass:: .. autoexception:: Document a module, class or exception. All three directives will by default only insert the docstring of the object itself: .. autoclass:: Noodle will produce source like this: .. class:: Noodle Noodle's docstring. The \u201cauto\u201d directives can also contain content of their own, it will be inserted into the resulting non-auto directive source after the docstring (but before any automatic member documentation). Therefore, you can also mix automatic and non-automatic member documentation, like so: .. autoclass:: Noodle :members: eat, slurp .. method:: boil(time=10) Boil the noodle *time* minutes. Options :members: (no value or comma separated list) If set, autodoc will generate document for the members of the target module, class or exception. For example: .. automodule:: noodle :members: will document all module members (recursively), and .. autoclass:: Noodle :members: will document all class member methods and properties. By default, autodoc will not generate document for the members that are private, not having docstrings, inherited from super class, or special members. For modules, __all__ will be respected when looking for members unless you give the ignore-module-all flag option. Without ignore-module-all, the order of the members will also be the order in __all__. You can also give an explicit list of members; only these will then be documented: .. autoclass:: Noodle :members: eat, slurp :undoc-members: (no value) If set, autodoc will also generate document for the members not having docstrings: .. automodule:: noodle :members: :undoc-members: :private-members: (no value or comma separated list) If set, autodoc will also generate document for the private members (that is, those named like _private or __private): .. automodule:: noodle :members: :private-members: It can also take an explicit list of member names to be documented as arguments: .. automodule:: noodle :members: :private-members: _spicy, _garlickly New in version 1.1. Changed in version 3.2: The option can now take arguments. :special-members: (no value or comma separated list) If set, autodoc will also generate document for the special members (that is, those named like __special__): .. autoclass:: my.Class :members: :special-members: It can also take an explicit list of member names to be documented as arguments: .. autoclass:: my.Class :members: :special-members: __init__, __name__ New in version 1.1. Changed in version 1.2: The option can now take arguments Options and advanced usage If you want to make the members option (or other options described below) the default, see autodoc_default_options. Tip You can use a negated form, 'no-flag', as an option of autodoc directive, to disable it temporarily. For example: .. automodule:: foo :no-undoc-members: Tip You can use autodoc directive options to temporarily override or extend default options which takes list as an input. For example: .. autoclass:: Noodle :members: eat :private-members: +_spicy, _garlickly Changed in version 3.5: The default options can be overridden or extended temporarily. autodoc considers a member private if its docstring contains :meta private: in its Info field lists. For example: def my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta private: \"\"\" New in version 3.0. autodoc considers a member public if its docstring contains :meta public: in its Info field lists, even if it starts with an underscore. For example: def _my_function(my_arg, my_other_arg): \"\"\"blah blah blah :meta public: \"\"\" New in version 3.1. autodoc considers a variable member does not have any default value if its docstring contains :meta hide-value: in its Info field lists. Example: var1 = None #: :meta hide-value: New in version 3.5. For classes and exceptions, members inherited from base classes will be left out when documenting all members, unless you give the inherited-members option, in addition to members: .. autoclass:: Noodle :members: :inherited-members: This can be combined with undoc-members to document all available members of the class or module. It can take an ancestor class not to document inherited members from it. By default, members of object class are not documented. To show them all, give None to the option. For example; If your class Foo is derived from list class and you don\u2019t want to document list.__len__(), you should specify a option :inherited-members: list to avoid special members of list class. Another example; If your class Foo has __str__ special method and autodoc directive has both inherited-members and special-members, __str__ will be documented as in the past, but other special method that are not implemented in your class Foo. Since v5.0, it can take a comma separated list of ancestor classes. It allows to suppress inherited members of several classes on the module at once by specifying the option to automodule directive. Note: this will lead to markup errors if the inherited members come from a module whose docstrings are not reST formatted. New in version 0.3. Changed in version 3.0: It takes an ancestor class name as an argument. Changed in version 5.0: It takes a comma separated list of ancestor class names. It\u2019s possible to override the signature for explicitly documented callable objects (functions, methods, classes) with the regular syntax that will override the signature gained from introspection: .. autoclass:: Noodle(type) .. automethod:: eat(persona) This is useful if the signature from the method is hidden by a decorator. New in version 0.4. The automodule, autoclass and autoexception directives also support a flag option called show-inheritance. When given, a list of base classes will be inserted just below the class signature (when used with automodule, this will be inserted for every class that is documented in the module). New in version 0.4. All autodoc directives support the noindex flag option that has the same effect as for standard py:function etc. directives: no index entries are generated for the documented object (and all autodocumented members). New in version 0.4. automodule also recognizes the synopsis, platform and deprecated options that the standard py:module directive supports. New in version 0.5. automodule and autoclass also has an member-order option that can be used to override the global value of autodoc_member_order for one directive. New in version 0.6. The directives supporting member documentation also have a exclude-members option that can be used to exclude single member names from documentation, if all members are to be documented. New in version 0.6. In an automodule directive with the members option set, only module members whose __module__ attribute is equal to the module name as given to automodule will be documented. This is to prevent documentation of imported classes or functions. Set the imported-members option if you want to prevent this behavior and document all available members. Note that attributes from imported modules will not be documented, because attribute documentation is discovered by parsing the source file of the current module. New in version 1.2. Add a list of modules in the autodoc_mock_imports to prevent import errors to halt the building process when some external dependencies are not importable at build time. New in version 1.3. As a hint to autodoc extension, you can put a :: separator in between module name and object name to let autodoc know the correct module name if it is ambiguous. .. autoclass:: module.name::Noodle autoclass also recognizes the class-doc-from option that can be used to override the global value of autoclass_content. New in version 4.1. .. autofunction:: .. autodecorator:: .. autodata:: .. automethod:: .. autoattribute:: .. autoproperty:: These work exactly like autoclass etc., but do not offer the options used for automatic member documentation. autodata and autoattribute support the annotation option. The option controls how the value of variable is shown. If specified without arguments, only the name of the variable will be printed, and its value is not shown: .. autodata:: CD_DRIVE :annotation: If the option specified with arguments, it is printed after the name as a value of the variable: .. autodata:: CD_DRIVE :annotation: = your CD device name By default, without annotation option, Sphinx tries to obtain the value of the variable and print it after the name. The no-value option can be used instead of a blank annotation to show the type hint but not the value: .. autodata:: CD_DRIVE :no-value: If both the annotation and no-value options are used, no-value has no effect. For module data members and class attributes, documentation can either be put into a comment with special formatting (using a #: to start the comment instead of just #), or in a docstring after the definition. Comments need to be either on a line of their own before the definition, or immediately after the assignment on the same line. The latter form is restricted to one line only. This means that in the following class definition, all attributes can be autodocumented: class Foo: \"\"\"Docstring for class Foo.\"\"\" #: Doc comment for class attribute Foo.bar. #: It can have multiple lines. bar = 1 flox = 1.5 #: Doc comment for Foo.flox. One line only. baz = 2 \"\"\"Docstring for class attribute Foo.baz.\"\"\" def __init__(self): #: Doc comment for instance attribute qux. self.qux = 3 self.spam = 4 \"\"\"Docstring for instance attribute spam.\"\"\" Changed in version 0.6: autodata and autoattribute can now extract docstrings. Changed in version 1.1: Comment docs are now allowed on the same line after an assignment. Changed in version 1.2: autodata and autoattribute have an annotation option. Changed in version 2.0: autodecorator added. Changed in version 2.1: autoproperty added. Changed in version 3.4: autodata and autoattribute now have a no-value option. Note If you document decorated functions or methods, keep in mind that autodoc retrieves its docstrings by importing the module and inspecting the __doc__ attribute of the given function or method. That means that if a decorator replaces the decorated function with another, it must copy the original __doc__ to the new function."
    },
    {
      "id": "configuration",
      "title": "Configuration",
      "content": "There are also config values that you can set: autoclass_content This value selects what content will be inserted into the main body of an autoclass directive. The possible values are: \"class\"Only the class\u2019 docstring is inserted. This is the default. You can still document __init__ as a separate method using automethod or the members option to autoclass. \"both\"Both the class\u2019 and the __init__ method\u2019s docstring are concatenated and inserted. \"init\"Only the __init__ method\u2019s docstring is inserted. New in version 0.3. If the class has no __init__ method or if the __init__ method\u2019s docstring is empty, but the class has a __new__ method\u2019s docstring, it is used instead. New in version 1.4. autodoc_class_signature This value selects how the signature will be displayed for the class defined by autoclass directive. The possible values are: \"mixed\"Display the signature with the class name. \"separated\"Display the signature as a method. The default is \"mixed\". New in version 4.1. autodoc_member_order This value selects if automatically documented members are sorted alphabetical (value 'alphabetical'), by member type (value 'groupwise') or by source order (value 'bysource'). The default is alphabetical. Note that for source order, the module must be a Python module with the source code available. New in version 0.6. Changed in version 1.0: Support for 'bysource'. autodoc_default_flags This value is a list of autodoc directive flags that should be automatically applied to all autodoc directives. The supported flags are 'members', 'undoc-members', 'private-members', 'special-members', 'inherited-members', 'show-inheritance', 'ignore-module-all' and 'exclude-members'. New in version 1.0. Deprecated since version 1.8: Integrated into autodoc_default_options. autodoc_default_options The default options for autodoc directives. They are applied to all autodoc directives automatically. It must be a dictionary which maps option names to the values. For example: autodoc_default_options = { 'members': 'var1, var2', 'member-order': 'bysource', 'special-members': '__init__', 'undoc-members': True, 'exclude-members': '__weakref__' } Setting None or True to the value is equivalent to giving only the option name to the directives. The supported options are 'members', 'member-order', 'undoc-members', 'private-members', 'special-members', 'inherited-members', 'show-inheritance', 'ignore-module-all', 'imported-members', 'exclude-members', 'class-doc-from' and 'no-value'. New in version 1.8. Changed in version 2.0: Accepts True as a value. Changed in version 2.1: Added 'imported-members'. Changed in version 4.1: Added 'class-doc-from'. Changed in version 4.5: Added 'no-value'. autodoc_docstring_signature Functions imported from C modules cannot be introspected, and therefore the signature for such functions cannot be automatically determined. However, it is an often-used convention to put the signature into the first line of the function\u2019s docstring. If this boolean value is set to True (which is the default), autodoc will look at the first line of the docstring for functions and methods, and if it looks like a signature, use the line as the signature and remove it from the docstring content. autodoc will continue to look for multiple signature lines, stopping at the first line that does not look like a signature. This is useful for declaring overloaded function signatures. New in version 1.1. Changed in version 3.1: Support overloaded signatures Changed in version 4.0: Overloaded signatures do not need to be separated by a backslash autodoc_mock_imports This value contains a list of modules to be mocked up. This is useful when some external dependencies are not met at build time and break the building process. You may only specify the root package of the dependencies themselves and omit the sub-modules: autodoc_mock_imports = [\"django\"] Will mock all imports under the django package. New in version 1.3. Changed in version 1.6: This config value only requires to declare the top-level modules that should be mocked. autodoc_typehints This value controls how to represent typehints. The setting takes the following values: 'signature' \u2013 Show typehints in the signature (default) 'description' \u2013 Show typehints as content of the function or method The typehints of overloaded functions or methods will still be represented in the signature. 'none' \u2013 Do not show typehints 'both' \u2013 Show typehints in the signature and as content of the function or method Overloaded functions or methods will not have typehints included in the description because it is impossible to accurately represent all possible overloads as a list of parameters. New in version 2.1. New in version 3.0: New option 'description' is added. New in version 4.1: New option 'both' is added. autodoc_typehints_description_target This value controls whether the types of undocumented parameters and return values are documented when autodoc_typehints is set to description. The default value is \"all\", meaning that types are documented for all parameters and return values, whether they are documented or not. When set to \"documented\", types will only be documented for a parameter or a return value that is already documented by the docstring. With \"documented_params\", parameter types will only be annotated if the parameter is documented in the docstring. The return type is always annotated (except if it is None). New in version 4.0. New in version 5.0: New option 'documented_params' is added. autodoc_type_aliases A dictionary for users defined type aliases that maps a type name to the full-qualified object name. It is used to keep type aliases not evaluated in the document. Defaults to empty ({}). The type aliases are only available if your program enables Postponed Evaluation of Annotations (PEP 563) feature via from __future__ import annotations. For example, there is code using a type alias: from __future__ import annotations AliasType = Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]] def f() -> AliasType: ... If autodoc_type_aliases is not set, autodoc will generate internal mark-up from this code as following: .. py:function:: f() -> Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]] ... If you set autodoc_type_aliases as {'AliasType': 'your.module.AliasType'}, it generates the following document internally: .. py:function:: f() -> your.module.AliasType: ... New in version 3.3. autodoc_typehints_format This value controls the format of typehints. The setting takes the following values: 'fully-qualified' \u2013 Show the module name and its name of typehints 'short' \u2013 Suppress the leading module names of the typehints (ex. io.StringIO -> StringIO) (default) New in version 4.4. Changed in version 5.0: The default setting was changed to 'short' autodoc_preserve_defaults If True, the default argument values of functions will be not evaluated on generating document. It preserves them as is in the source code. New in version 4.0: Added as an experimental feature. This will be integrated into autodoc core in the future. autodoc_warningiserror This value controls the behavior of sphinx-build -W during importing modules. If False is given, autodoc forcedly suppresses the error if the imported module emits warnings. By default, True. autodoc_inherit_docstrings This value controls the docstrings inheritance. If set to True the docstring for classes or methods, if not explicitly set, is inherited from parents. The default is True. New in version 1.7. suppress_warnings autodoc supports to suppress warning messages via suppress_warnings. It allows following warnings types in addition: autodoc autodoc.import_object"
    },
    {
      "id": "docstring-preprocessing",
      "title": "Docstring preprocessing",
      "content": "autodoc provides the following additional events: autodoc-process-docstring(app, what, name, obj, options, lines) New in version 0.4. Emitted when autodoc has read and processed a docstring. lines is a list of strings \u2013 the lines of the processed docstring \u2013 that the event handler can modify in place to change what Sphinx puts into the output. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive lines \u2013 the lines of the docstring, see above autodoc-before-process-signature(app, obj, bound_method) New in version 2.4. Emitted before autodoc formats a signature for an object. The event handler can modify an object to change its signature. Parameters: app \u2013 the Sphinx application object obj \u2013 the object itself bound_method \u2013 a boolean indicates an object is bound method or not autodoc-process-signature(app, what, name, obj, options, signature, return_annotation) New in version 0.5. Emitted when autodoc has formatted a signature for an object. The event handler can return a new tuple (signature, return_annotation) to change what Sphinx puts into the output. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive signature \u2013 function signature, as a string of the form \"(parameter_1, parameter_2)\", or None if introspection didn\u2019t succeed and signature wasn\u2019t specified in the directive. return_annotation \u2013 function return annotation as a string of the form \" -> annotation\", or None if there is no return annotation The sphinx.ext.autodoc module provides factory functions for commonly needed docstring processing in event autodoc-process-docstring: sphinx.ext.autodoc.cut_lines(pre: int, post: int = 0, what: str | None = None) \u2192 Callable[source] Return a listener that removes the first pre and last post lines of every docstring. If what is a sequence of strings, only docstrings of a type in what will be processed. Use like this (e.g. in the setup() function of conf.py): from sphinx.ext.autodoc import cut_lines app.connect('autodoc-process-docstring', cut_lines(4, what=['module'])) This can (and should) be used in place of automodule_skip_lines. sphinx.ext.autodoc.between(marker: str, what: Sequence[str] | None = None, keepempty: bool = False, exclude: bool = False) \u2192 Callable[source] Return a listener that either keeps, or if exclude is True excludes, lines between lines that match the marker regular expression. If no line matches, the resulting docstring would be empty, so no change will be made unless keepempty is true. If what is a sequence of strings, only docstrings of a type in what will be processed. autodoc-process-bases(app, name, obj, options, bases) Emitted when autodoc has read and processed a class to determine the base-classes. bases is a list of classes that the event handler can modify in place to change what Sphinx puts into the output. It\u2019s emitted only if show-inheritance option given. Parameters: app \u2013 the Sphinx application object name \u2013 the fully qualified name of the object obj \u2013 the object itself options \u2013 the options given to the class directive bases \u2013 the list of base classes signature. see above. New in version 4.1. Changed in version 4.3: bases can contain a string as a base class name. It will be processed as reST mark-up\u2019ed text."
    },
    {
      "id": "skipping-members",
      "title": "Skipping members",
      "content": "autodoc allows the user to define a custom method for determining whether a member should be included in the documentation by using the following event: autodoc-skip-member(app, what, name, obj, skip, options) New in version 0.5. Emitted when autodoc has to decide whether a member should be included in the documentation. The member is excluded if a handler returns True. It is included if the handler returns False. If more than one enabled extension handles the autodoc-skip-member event, autodoc will use the first non-None value returned by a handler. Handlers should return None to fall back to the skipping behavior of autodoc and other enabled extensions. Parameters: app \u2013 the Sphinx application object what \u2013 the type of the object which the docstring belongs to (one of \"module\", \"class\", \"exception\", \"function\", \"method\", \"attribute\") name \u2013 the fully qualified name of the object obj \u2013 the object itself skip \u2013 a boolean indicating if autodoc will skip this member if the user handler does not override the decision options \u2013 the options given to the directive: an object with attributes inherited_members, undoc_members, show_inheritance and noindex that are true if the flag option of same name was given to the auto directive"
    },
    {
      "id": "directive-automodule",
      "title": ".. automodule::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-autoclass",
      "title": ".. autoclass::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-autoexception",
      "title": ".. autoexception::",
      "content": "Document a module, class or exception.  All three directives will by default\nonly insert the docstring of the object itself:\n.. autoclass:: Noodle\n\n\nwill produce source like this:\n.. class:: Noodle\n\n   Noodle's docstring.\n\n\nThe \u201cauto\u201d directives can also contain content of their own, it will be\ninserted into the resulting non-auto directive source after the docstring\n(but before any automatic member documentation).\nTherefore, you can also mix automatic and non-automatic member documentation,\nlike so:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n   .. method:: boil(time=10)\n\n      Boil the noodle *time* minutes.\n\n\nOptions\n\n\n:members: (no value or comma separated list)\nIf set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n\n\n\n\n:undoc-members: (no value)\nIf set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n\n\n\n\n:private-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n\n\n\n\n:special-members: (no value or comma separated list)\nIf set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n\n\nOptions and advanced usage\n\nIf you want to make the members option (or other options described\nbelow) the default, see autodoc_default_options.\n\nTip\nYou can use a negated form, 'no-flag', as an option of\nautodoc directive, to disable it temporarily.  For example:\n.. automodule:: foo\n   :no-undoc-members:\n\n\n\n\nTip\nYou can use autodoc directive options to temporarily override or\nextend default options which takes list as an input. For example:\n.. autoclass:: Noodle\n   :members: eat\n   :private-members: +_spicy, _garlickly\n\n\n\n\nChanged in version 3.5: The default options can be overridden or extended temporarily.\n\n\nautodoc considers a member private if its docstring contains\n:meta private: in its Info field lists.\nFor example:\ndef my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta private:\n    \"\"\"\n\n\n\nNew in version 3.0.\n\n\nautodoc considers a member public if its docstring contains\n:meta public: in its Info field lists, even if it starts with\nan underscore.\nFor example:\ndef _my_function(my_arg, my_other_arg):\n    \"\"\"blah blah blah\n\n    :meta public:\n    \"\"\"\n\n\n\nNew in version 3.1.\n\n\nautodoc considers a variable member does not have any default value if its\ndocstring contains :meta hide-value: in its Info field lists.\nExample:\nvar1 = None  #: :meta hide-value:\n\n\n\nNew in version 3.5.\n\n\nFor classes and exceptions, members inherited from base classes will be\nleft out when documenting all members, unless you give the\ninherited-members option, in addition to members:\n.. autoclass:: Noodle\n   :members:\n   :inherited-members:\n\n\nThis can be combined with undoc-members to document all available\nmembers of the class or module.\nIt can take an ancestor class not to document inherited members from it.\nBy default, members of object class are not documented.  To show them\nall, give None to the option.\nFor example; If your class Foo is derived from list class and\nyou don\u2019t want to document list.__len__(), you should specify a\noption :inherited-members: list to avoid special members of list\nclass.\nAnother example; If your class Foo has __str__ special method and\nautodoc directive has both inherited-members and special-members,\n__str__ will be documented as in the past, but other special method\nthat are not implemented in your class Foo.\nSince v5.0, it can take a comma separated list of ancestor classes.  It\nallows to suppress inherited members of several classes on the module at\nonce by specifying the option to automodule directive.\nNote: this will lead to markup errors if the inherited members come from a\nmodule whose docstrings are not reST formatted.\n\nNew in version 0.3.\n\n\nChanged in version 3.0: It takes an ancestor class name as an argument.\n\n\nChanged in version 5.0: It takes a comma separated list of ancestor class names.\n\n\nIt\u2019s possible to override the signature for explicitly documented callable\nobjects (functions, methods, classes) with the regular syntax that will\noverride the signature gained from introspection:\n.. autoclass:: Noodle(type)\n\n   .. automethod:: eat(persona)\n\n\nThis is useful if the signature from the method is hidden by a decorator.\n\nNew in version 0.4.\n\n\nThe automodule, autoclass and\nautoexception directives also support a flag option called\nshow-inheritance.  When given, a list of base classes will be inserted\njust below the class signature (when used with automodule, this\nwill be inserted for every class that is documented in the module).\n\nNew in version 0.4.\n\n\nAll autodoc directives support the noindex flag option that has the\nsame effect as for standard py:function etc. directives: no\nindex entries are generated for the documented object (and all\nautodocumented members).\n\nNew in version 0.4.\n\n\nautomodule also recognizes the synopsis, platform and\ndeprecated options that the standard py:module directive\nsupports.\n\nNew in version 0.5.\n\n\nautomodule and autoclass also has an member-order\noption that can be used to override the global value of\nautodoc_member_order for one directive.\n\nNew in version 0.6.\n\n\nThe directives supporting member documentation also have a\nexclude-members option that can be used to exclude single member names\nfrom documentation, if all members are to be documented.\n\nNew in version 0.6.\n\n\nIn an automodule directive with the members option set, only\nmodule members whose __module__ attribute is equal to the module name\nas given to automodule will be documented.  This is to prevent\ndocumentation of imported classes or functions.  Set the\nimported-members option if you want to prevent this behavior and\ndocument all available members.  Note that attributes from imported modules\nwill not be documented, because attribute documentation is discovered by\nparsing the source file of the current module.\n\nNew in version 1.2.\n\n\nAdd a list of modules in the autodoc_mock_imports to prevent\nimport errors to halt the building process when some external dependencies\nare not importable at build time.\n\nNew in version 1.3.\n\n\nAs a hint to autodoc extension, you can put a :: separator in between\nmodule name and object name to let autodoc know the correct module name if\nit is ambiguous.\n.. autoclass:: module.name::Noodle\n\n\n\nautoclass also recognizes the class-doc-from option that\ncan be used to override the global value of autoclass_content.\n\nNew in version 4.1.\n\n\n\n"
    },
    {
      "id": "directive-option-automodule-members",
      "title": ":members: (no value or comma separated list)",
      "content": "If set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n"
    },
    {
      "id": "directive-option-automodule-undoc-members",
      "title": ":undoc-members: (no value)",
      "content": "If set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n"
    },
    {
      "id": "directive-option-automodule-private-members",
      "title": ":private-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n"
    },
    {
      "id": "directive-option-automodule-special-members",
      "title": ":special-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n"
    },
    {
      "id": "directive-option-automodule-members",
      "title": ":members: (no value or comma separated list)",
      "content": "If set, autodoc will generate document for the members of the target\nmodule, class or exception.\nFor example:\n.. automodule:: noodle\n   :members:\n\n\nwill document all module members (recursively), and\n.. autoclass:: Noodle\n   :members:\n\n\nwill document all class member methods and properties.\nBy default, autodoc will not generate document for the members that are\nprivate, not having docstrings, inherited from super class, or special\nmembers.\nFor modules, __all__ will be respected when looking for members unless\nyou give the ignore-module-all flag option.  Without\nignore-module-all, the order of the members will also be the order in\n__all__.\nYou can also give an explicit list of members; only these will then be\ndocumented:\n.. autoclass:: Noodle\n   :members: eat, slurp\n\n\n"
    },
    {
      "id": "directive-option-automodule-undoc-members",
      "title": ":undoc-members: (no value)",
      "content": "If set, autodoc will also generate document for the members not having\ndocstrings:\n.. automodule:: noodle\n   :members:\n   :undoc-members:\n\n\n"
    },
    {
      "id": "directive-option-automodule-private-members",
      "title": ":private-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the private members\n(that is, those named like _private or __private):\n.. automodule:: noodle\n   :members:\n   :private-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. automodule:: noodle\n   :members:\n   :private-members: _spicy, _garlickly\n\n\n\nNew in version 1.1.\n\n\nChanged in version 3.2: The option can now take arguments.\n\n"
    },
    {
      "id": "directive-option-automodule-special-members",
      "title": ":special-members: (no value or comma separated list)",
      "content": "If set, autodoc will also generate document for the special members\n(that is, those named like __special__):\n.. autoclass:: my.Class\n   :members:\n   :special-members:\n\n\nIt can also take an explicit list of member names to be documented as\narguments:\n.. autoclass:: my.Class\n   :members:\n   :special-members: __init__, __name__\n\n\n\nNew in version 1.1.\n\n\nChanged in version 1.2: The option can now take arguments\n\n"
    },
    {
      "id": "directive-autofunction",
      "title": ".. autofunction::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autodecorator",
      "title": ".. autodecorator::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autodata",
      "title": ".. autodata::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-automethod",
      "title": ".. automethod::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autoattribute",
      "title": ".. autoattribute::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "directive-autoproperty",
      "title": ".. autoproperty::",
      "content": "These work exactly like autoclass etc.,\nbut do not offer the options used for automatic member documentation.\nautodata and autoattribute support the annotation\noption.  The option controls how the value of variable is shown.  If specified\nwithout arguments, only the name of the variable will be printed, and its value\nis not shown:\n.. autodata:: CD_DRIVE\n   :annotation:\n\n\nIf the option specified with arguments, it is printed after the name as a value\nof the variable:\n.. autodata:: CD_DRIVE\n   :annotation: = your CD device name\n\n\nBy default, without annotation option, Sphinx tries to obtain the value of\nthe variable and print it after the name.\nThe no-value option can be used instead of a blank annotation to show the\ntype hint but not the value:\n.. autodata:: CD_DRIVE\n   :no-value:\n\n\nIf both the annotation and no-value options are used, no-value has no\neffect.\nFor module data members and class attributes, documentation can either be put\ninto a comment with special formatting (using a #: to start the comment\ninstead of just #), or in a docstring after the definition.  Comments\nneed to be either on a line of their own before the definition, or\nimmediately after the assignment on the same line.  The latter form is\nrestricted to one line only.\nThis means that in the following class definition, all attributes can be\nautodocumented:\nclass Foo:\n    \"\"\"Docstring for class Foo.\"\"\"\n\n    #: Doc comment for class attribute Foo.bar.\n    #: It can have multiple lines.\n    bar = 1\n\n    flox = 1.5   #: Doc comment for Foo.flox. One line only.\n\n    baz = 2\n    \"\"\"Docstring for class attribute Foo.baz.\"\"\"\n\n    def __init__(self):\n        #: Doc comment for instance attribute qux.\n        self.qux = 3\n\n        self.spam = 4\n        \"\"\"Docstring for instance attribute spam.\"\"\"\n\n\n\nChanged in version 0.6: autodata and autoattribute can now extract\ndocstrings.\n\n\nChanged in version 1.1: Comment docs are now allowed on the same line after an assignment.\n\n\nChanged in version 1.2: autodata and autoattribute have an annotation\noption.\n\n\nChanged in version 2.0: autodecorator added.\n\n\nChanged in version 2.1: autoproperty added.\n\n\nChanged in version 3.4: autodata and autoattribute now have a no-value\noption.\n\n\nNote\nIf you document decorated functions or methods, keep in mind that autodoc\nretrieves its docstrings by importing the module and inspecting the\n__doc__ attribute of the given function or method.  That means that if\na decorator replaces the decorated function with another, it must copy the\noriginal __doc__ to the new function.\n\n"
    },
    {
      "id": "confval-autoclass_content",
      "title": "autoclass_content",
      "content": "This value selects what content will be inserted into the main body of an\nautoclass directive.  The possible values are:\n\n\"class\"Only the class\u2019 docstring is inserted.  This is the default.  You can\nstill document __init__ as a separate method using\nautomethod or the members option to autoclass.\n\n\"both\"Both the class\u2019 and the __init__ method\u2019s docstring are concatenated\nand inserted.\n\n\"init\"Only the __init__ method\u2019s docstring is inserted.\n\n\n\nNew in version 0.3.\n\nIf the class has no __init__ method or if the __init__ method\u2019s\ndocstring is empty, but the class has a __new__ method\u2019s docstring,\nit is used instead.\n\nNew in version 1.4.\n\n"
    },
    {
      "id": "confval-autodoc_class_signature",
      "title": "autodoc_class_signature",
      "content": "This value selects how the signature will be displayed for the class defined\nby autoclass directive.  The possible values are:\n\n\"mixed\"Display the signature with the class name.\n\n\"separated\"Display the signature as a method.\n\n\nThe default is \"mixed\".\n\nNew in version 4.1.\n\n"
    },
    {
      "id": "confval-autodoc_member_order",
      "title": "autodoc_member_order",
      "content": "This value selects if automatically documented members are sorted\nalphabetical (value 'alphabetical'), by member type (value\n'groupwise') or by source order (value 'bysource').  The default is\nalphabetical.\nNote that for source order, the module must be a Python module with the\nsource code available.\n\nNew in version 0.6.\n\n\nChanged in version 1.0: Support for 'bysource'.\n\n"
    },
    {
      "id": "confval-autodoc_default_flags",
      "title": "autodoc_default_flags",
      "content": "This value is a list of autodoc directive flags that should be automatically\napplied to all autodoc directives.  The supported flags are 'members',\n'undoc-members', 'private-members', 'special-members',\n'inherited-members', 'show-inheritance', 'ignore-module-all'\nand 'exclude-members'.\n\nNew in version 1.0.\n\n\nDeprecated since version 1.8: Integrated into autodoc_default_options.\n\n"
    },
    {
      "id": "confval-autodoc_default_options",
      "title": "autodoc_default_options",
      "content": "The default options for autodoc directives.  They are applied to all autodoc\ndirectives automatically.  It must be a dictionary which maps option names\nto the values.  For example:\nautodoc_default_options = {\n    'members': 'var1, var2',\n    'member-order': 'bysource',\n    'special-members': '__init__',\n    'undoc-members': True,\n    'exclude-members': '__weakref__'\n}\n\n\nSetting None or True to the value is equivalent to giving only the\noption name to the directives.\nThe supported options are 'members', 'member-order',\n'undoc-members', 'private-members', 'special-members',\n'inherited-members', 'show-inheritance', 'ignore-module-all',\n'imported-members', 'exclude-members', 'class-doc-from' and\n'no-value'.\n\nNew in version 1.8.\n\n\nChanged in version 2.0: Accepts True as a value.\n\n\nChanged in version 2.1: Added 'imported-members'.\n\n\nChanged in version 4.1: Added 'class-doc-from'.\n\n\nChanged in version 4.5: Added 'no-value'.\n\n"
    },
    {
      "id": "confval-autodoc_docstring_signature",
      "title": "autodoc_docstring_signature",
      "content": "Functions imported from C modules cannot be introspected, and therefore the\nsignature for such functions cannot be automatically determined.  However, it\nis an often-used convention to put the signature into the first line of the\nfunction\u2019s docstring.\nIf this boolean value is set to True (which is the default), autodoc will\nlook at the first line of the docstring for functions and methods, and if it\nlooks like a signature, use the line as the signature and remove it from the\ndocstring content.\nautodoc will continue to look for multiple signature lines,\nstopping at the first line that does not look like a signature.\nThis is useful for declaring overloaded function signatures.\n\nNew in version 1.1.\n\n\nChanged in version 3.1: Support overloaded signatures\n\n\nChanged in version 4.0: Overloaded signatures do not need to be separated by a backslash\n\n"
    },
    {
      "id": "confval-autodoc_mock_imports",
      "title": "autodoc_mock_imports",
      "content": "This value contains a list of modules to be mocked up. This is useful when\nsome external dependencies are not met at build time and break the building\nprocess. You may only specify the root package of the dependencies\nthemselves and omit the sub-modules:\nautodoc_mock_imports = [\"django\"]\n\n\nWill mock all imports under the django package.\n\nNew in version 1.3.\n\n\nChanged in version 1.6: This config value only requires to declare the top-level modules that\nshould be mocked.\n\n"
    },
    {
      "id": "confval-autodoc_typehints",
      "title": "autodoc_typehints",
      "content": "This value controls how to represent typehints.  The setting takes the\nfollowing values:\n\n'signature' \u2013 Show typehints in the signature (default)\n'description' \u2013 Show typehints as content of the function or method\nThe typehints of overloaded functions or methods will still be represented\nin the signature.\n'none' \u2013 Do not show typehints\n'both' \u2013 Show typehints in the signature and as content of\nthe function or method\n\nOverloaded functions or methods will not have typehints included in the\ndescription because it is impossible to accurately represent all possible\noverloads as a list of parameters.\n\nNew in version 2.1.\n\n\nNew in version 3.0: New option 'description' is added.\n\n\nNew in version 4.1: New option 'both' is added.\n\n"
    },
    {
      "id": "confval-autodoc_typehints_description_target",
      "title": "autodoc_typehints_description_target",
      "content": "This value controls whether the types of undocumented parameters and return\nvalues are documented when autodoc_typehints is set to description.\nThe default value is \"all\", meaning that types are documented for all\nparameters and return values, whether they are documented or not.\nWhen set to \"documented\", types will only be documented for a parameter\nor a return value that is already documented by the docstring.\nWith \"documented_params\", parameter types will only be annotated if the\nparameter is documented in the docstring. The return type is always\nannotated (except if it is None).\n\nNew in version 4.0.\n\n\nNew in version 5.0: New option 'documented_params' is added.\n\n"
    },
    {
      "id": "confval-autodoc_type_aliases",
      "title": "autodoc_type_aliases",
      "content": "A dictionary for users defined type aliases that maps a type name to the\nfull-qualified object name.  It is used to keep type aliases not evaluated in\nthe document.  Defaults to empty ({}).\nThe type aliases are only available if your program enables Postponed\nEvaluation of Annotations (PEP 563) feature via from __future__ import\nannotations.\nFor example, there is code using a type alias:\nfrom __future__ import annotations\n\nAliasType = Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]\n\ndef f() -> AliasType:\n    ...\n\n\nIf autodoc_type_aliases is not set, autodoc will generate internal mark-up\nfrom this code as following:\n.. py:function:: f() -> Union[List[Dict[Tuple[int, str], Set[int]]], Tuple[str, List[str]]]\n\n   ...\n\n\nIf you set autodoc_type_aliases as\n{'AliasType': 'your.module.AliasType'}, it generates the following document\ninternally:\n.. py:function:: f() -> your.module.AliasType:\n\n   ...\n\n\n\nNew in version 3.3.\n\n"
    },
    {
      "id": "confval-autodoc_typehints_format",
      "title": "autodoc_typehints_format",
      "content": "This value controls the format of typehints.  The setting takes the\nfollowing values:\n\n'fully-qualified' \u2013 Show the module name and its name of typehints\n'short' \u2013 Suppress the leading module names of the typehints\n(ex. io.StringIO -> StringIO)  (default)\n\n\nNew in version 4.4.\n\n\nChanged in version 5.0: The default setting was changed to 'short'\n\n"
    },
    {
      "id": "confval-autodoc_preserve_defaults",
      "title": "autodoc_preserve_defaults",
      "content": "If True, the default argument values of functions will be not evaluated on\ngenerating document.  It preserves them as is in the source code.\n\nNew in version 4.0: Added as an experimental feature.  This will be integrated into autodoc core\nin the future.\n\n"
    },
    {
      "id": "confval-autodoc_warningiserror",
      "title": "autodoc_warningiserror",
      "content": "This value controls the behavior of sphinx-build -W during\nimporting modules.\nIf False is given, autodoc forcedly suppresses the error if the imported\nmodule emits warnings.  By default, True.\n"
    },
    {
      "id": "confval-autodoc_inherit_docstrings",
      "title": "autodoc_inherit_docstrings",
      "content": "This value controls the docstrings inheritance.\nIf set to True the docstring for classes or methods, if not explicitly set,\nis inherited from parents.\nThe default is True.\n\nNew in version 1.7.\n\n"
    },
    {
      "id": "event-autodoc-process-docstring",
      "title": "autodoc-process-docstring(app, what, name, obj, options, lines)",
      "content": "\nNew in version 0.4.\n\nEmitted when autodoc has read and processed a docstring.  lines is a list\nof strings \u2013 the lines of the processed docstring \u2013 that the event handler\ncan modify in place to change what Sphinx puts into the output.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\nlines \u2013 the lines of the docstring, see above\n\n\n\n"
    },
    {
      "id": "event-autodoc-before-process-signature",
      "title": "autodoc-before-process-signature(app, obj, bound_method)",
      "content": "\nNew in version 2.4.\n\nEmitted before autodoc formats a signature for an object. The event handler\ncan modify an object to change its signature.\n\nParameters:\n\napp \u2013 the Sphinx application object\nobj \u2013 the object itself\nbound_method \u2013 a boolean indicates an object is bound method or not\n\n\n\n"
    },
    {
      "id": "event-autodoc-process-signature",
      "title": "autodoc-process-signature(app, what, name, obj, options, signature, return_annotation)",
      "content": "\nNew in version 0.5.\n\nEmitted when autodoc has formatted a signature for an object. The event\nhandler can return a new tuple (signature, return_annotation) to change\nwhat Sphinx puts into the output.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\nsignature \u2013 function signature, as a string of the form\n\"(parameter_1, parameter_2)\", or None if introspection didn\u2019t\nsucceed and signature wasn\u2019t specified in the directive.\nreturn_annotation \u2013 function return annotation as a string of the form\n\" -> annotation\", or None if there is no return annotation\n\n\n\n"
    },
    {
      "id": "sphinx.ext.autodoc.cut_lines",
      "title": "sphinx.ext.autodoc.cut_lines(pre: int, post: int = 0, what: str | None = None) \u2192 Callable[source]",
      "content": "Return a listener that removes the first pre and last post\nlines of every docstring.  If what is a sequence of strings,\nonly docstrings of a type in what will be processed.\nUse like this (e.g. in the setup() function of conf.py):\nfrom sphinx.ext.autodoc import cut_lines\napp.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n\n\nThis can (and should) be used in place of automodule_skip_lines.\n"
    },
    {
      "id": "sphinx.ext.autodoc.between",
      "title": "sphinx.ext.autodoc.between(marker: str, what: Sequence[str] | None = None, keepempty: bool = False, exclude: bool = False) \u2192 Callable[source]",
      "content": "Return a listener that either keeps, or if exclude is True excludes,\nlines between lines that match the marker regular expression.  If no line\nmatches, the resulting docstring would be empty, so no change will be made\nunless keepempty is true.\nIf what is a sequence of strings, only docstrings of a type in what will\nbe processed.\n"
    },
    {
      "id": "event-autodoc-process-bases",
      "title": "autodoc-process-bases(app, name, obj, options, bases)",
      "content": "Emitted when autodoc has read and processed a class to determine the\nbase-classes.  bases is a list of classes that the event handler can\nmodify in place to change what Sphinx puts into the output.  It\u2019s\nemitted only if show-inheritance option given.\n\nParameters:\n\napp \u2013 the Sphinx application object\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\noptions \u2013 the options given to the class directive\nbases \u2013 the list of base classes signature. see above.\n\n\n\n\nNew in version 4.1.\n\n\nChanged in version 4.3: bases can contain a string as a base class name.  It will be processed\nas reST mark-up\u2019ed text.\n\n"
    },
    {
      "id": "event-autodoc-skip-member",
      "title": "autodoc-skip-member(app, what, name, obj, skip, options)",
      "content": "\nNew in version 0.5.\n\nEmitted when autodoc has to decide whether a member should be included in the\ndocumentation.  The member is excluded if a handler returns True.  It is\nincluded if the handler returns False.\nIf more than one enabled extension handles the autodoc-skip-member\nevent, autodoc will use the first non-None value returned by a handler.\nHandlers should return None to fall back to the skipping behavior of\nautodoc and other enabled extensions.\n\nParameters:\n\napp \u2013 the Sphinx application object\nwhat \u2013 the type of the object which the docstring belongs to (one of\n\"module\", \"class\", \"exception\", \"function\", \"method\",\n\"attribute\")\nname \u2013 the fully qualified name of the object\nobj \u2013 the object itself\nskip \u2013 a boolean indicating if autodoc will skip this member if the\nuser handler does not override the decision\noptions \u2013 the options given to the directive: an object with attributes\ninherited_members, undoc_members, show_inheritance and\nnoindex that are true if the flag option of same name was given to the\nauto directive\n\n\n\n"
    }
  ],
  "domain_data": {}
}
